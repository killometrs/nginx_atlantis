name: Build and Deploy to Kubernetes

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: cr.yandex/${{ secrets.YC_REGISTRY_ID }}/diplom-nginx-app-nginx

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Test Docker build
      run: docker build -t test-diplom-nginx-image .

    - name: Install HTML validator
      run: |
        npm install -g html-validate

    - name: Validate HTML files
      run: |
        cat > .htmlvalidate.json << EOF
        {
          "rules": {
            "element-required-attributes": "off"
          }
        }
        EOF
        html-validate ./html/**/*.html

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Install dependencies
      run: sudo apt-get update && sudo apt-get install -y jq openssl python3 python3-pip

    - name: Install python cryptography library for PS256
      run: pip3 install pyjwt cryptography

    - name: Create Python script for JWT generation
      run: |
        cat > generate_jwt.py << 'PYTHON_EOF'
import json
import time
import jwt
from cryptography.hazmat.primitives import serialization

# Читаем ключ
with open('private_key.pem', 'r') as f:
    private_key_pem = f.read()

private_key = serialization.load_pem_private_key(
    private_key_pem.encode(),
    password=None
)

# Подготавливаем claims
now = int(time.time())
expires = now + 3600

payload = {
    'aud': 'https://iam.api.cloud.yandex.net/iam/v1/tokens',
    'iss': '$SERVICE_ACCOUNT_ID',
    'iat': now,
    'exp': expires
}

# Создаем JWT с PS256 алгоритмом
jwt_token = jwt.encode(
    payload,
    private_key,
    algorithm='PS256',
    headers={'kid': '$KEY_ID', 'typ': 'JWT', 'alg': 'PS256'}
)

print(jwt_token)
PYTHON_EOF

    - name: Login to Yandex Container Registry with JWT
      run: |
        # Создаем временный файл с JSON ключом
        echo '${{ secrets.YC_SA_JSON_KEY }}' > key.json
        
        # Извлекаем данные из key.json
        SERVICE_ACCOUNT_ID=$(jq -r '.service_account_id' key.json)
        KEY_ID=$(jq -r '.id' key.json)
        PRIVATE_KEY_PEM=$(jq -r '.private_key' key.json | sed 's/\\n/\n/g')
        
        echo "Service Account ID: $SERVICE_ACCOUNT_ID"
        echo "Key ID: $KEY_ID"
        
        # Сохраняем private key в файл
        echo "$PRIVATE_KEY_PEM" > private_key.pem
        
        # Заменяем переменные в Python скрипте
        sed -i "s/\$SERVICE_ACCOUNT_ID/$SERVICE_ACCOUNT_ID/g" generate_jwt.py
        sed -i "s/\$KEY_ID/$KEY_ID/g" generate_jwt.py
        
        # Используем Python для создания JWT с PS256 подписью
        python3 generate_jwt.py > jwt_token.txt

        JWT_TOKEN=$(cat jwt_token.txt)
        echo "JWT Token created successfully"
        
        # Обмен JWT на IAM-токен
        RESPONSE=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          --data '{"jwt":"'"$JWT_TOKEN"'"}' \
          "https://iam.api.cloud.yandex.net/iam/v1/tokens")
        
        # Получаем IAM токен
        IAM_TOKEN=$(echo "$RESPONSE" | jq -r '.iamToken')
        
        if [ "$IAM_TOKEN" != "null" ] && [ -n "$IAM_TOKEN" ]; then
          echo "IAM token successfully received"
          # Логинимся в registry используя IAM токен
          echo "$IAM_TOKEN" | docker login --username iam --password-stdin cr.yandex
        else
          echo "Error getting IAM token:"
          echo "$RESPONSE"
          exit 1
        fi

    - name: Extract tag name
      id: tag
      run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ env.IMAGE_NAME }}:latest
          ${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.TAG }}
        cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
        cache-to: type=inline

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Verify cluster access
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Extract tag name
      id: tag
      run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Create namespace if not exists
      run: |
        if ! kubectl get namespace diplom-nginx-namespace; then
          echo "Creating namespace diplom-nginx-namespace"
          kubectl create namespace diplom-nginx-namespace
        else
          echo "Namespace diplom-nginx-namespace already exists"
        fi

    - name: Create nginx config for path routing
      run: |
        cat > nginx-config.yaml << EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: nginx-config
          namespace: diplom-nginx-namespace
        data:
          nginx.conf: |
            events {
                worker_connections 1024;
            }
            
            http {
                include /etc/nginx/mime.types;
                default_type application/octet-stream;
                
                server {
                    listen 80;
                    server_name _;
                    
                    location /nginx {
                        alias /usr/share/nginx/html;
                        index index.html;
                        try_files \$uri \$uri/ /nginx/index.html;
                    }
                    
                    location /nginx/ {
                        alias /usr/share/nginx/html/;
                        try_files \$uri \$uri/ =404;
                    }
                    
                    location = / {
                        return 302 /nginx;
                    }
                }
            }
        EOF
        kubectl apply -f nginx-config.yaml

    - name: Create or update deployment
      run: |
        cat > deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: diplom-nginx-app
          namespace: diplom-nginx-namespace
          labels:
            app: diplom-nginx-app
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: diplom-nginx-app
          template:
            metadata:
              labels:
                app: diplom-nginx-app
            spec:
              containers:
              - name: diplom-nginx-app
                image: ${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.TAG }}
                ports:
                - containerPort: 80
                resources:
                  requests:
                    memory: "64Mi"
                    cpu: "50m"
                  limits:
                    memory: "128Mi"
                    cpu: "100m"
                volumeMounts:
                - name: nginx-config
                  mountPath: /etc/nginx/nginx.conf
                  subPath: nginx.conf
                livenessProbe:
                  httpGet:
                    path: /nginx
                    port: 80
                  initialDelaySeconds: 10
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /nginx
                    port: 80
                  initialDelaySeconds: 5
                  periodSeconds: 5
              volumes:
              - name: nginx-config
                configMap:
                  name: nginx-config
        EOF
        kubectl apply -f deployment.yaml

    - name: Create or update service
      run: |
        cat > service.yaml << EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: diplom-nginx-service
          namespace: diplom-nginx-namespace
        spec:
          selector:
            app: diplom-nginx-app
          ports:
          - port: 80
            targetPort: 80
          type: ClusterIP
        EOF
        kubectl apply -f service.yaml

    - name: Create ingress for nginx path
      run: |
        cat > ingress.yaml << EOF
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: nginx-ingress
          namespace: diplom-nginx-namespace
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /$2
            nginx.ingress.kubernetes.io/ssl-redirect: "false"
        spec:
          rules:
          - http:
              paths:
              - path: /nginx(/|$)(.*)
                pathType: Prefix
                backend:
                  service:
                    name: diplom-nginx-service
                    port:
                      number: 80
        EOF
        kubectl apply -f ingress.yaml

    - name: Wait for deployment rollout
      run: |
        kubectl rollout status deployment/diplom-nginx-app --namespace=diplom-nginx-namespace --timeout=300s

    - name: Verify deployment
      run: |
        echo "=== Deployment status ==="
        kubectl get deployments -n diplom-nginx-namespace
        echo "=== Pods status ==="
        kubectl get pods -n diplom-nginx-namespace
        echo "=== Service status ==="
        kubectl get services -n diplom-nginx-namespace
        echo "=== Ingress status ==="
        kubectl get ingress -n diplom-nginx-namespace
        echo "=== Current image version ==="
        kubectl describe deployment diplom-nginx-app -n diplom-nginx-namespace | grep Image:
