name: Build and Deploy to Kubernetes

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: cr.yandex/${{ secrets.YC_REGISTRY_ID }}/diplom-nginx-app-nginx

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Test Docker build
      run: docker build -t test-diplom-nginx-image .

    - name: Install HTML validator
      run: |
        npm install -g html-validate

    - name: Validate HTML files
      run: |
        cat > .htmlvalidate.json << 'EOF'
        {
          "rules": {
            "element-required-attributes": "off"
          }
        }
        EOF
        html-validate ./html/**/*.html

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Yandex Container Registry
      uses: yc-actions/yc-cr-login@v2
      with:
        yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_KEY }}

    - name: Extract tag name
      id: tag
      run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ env.IMAGE_NAME }}:latest
          ${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.TAG }}
        cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
        cache-to: type=inline

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG }}" > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Verify cluster access
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Extract tag name
      id: tag
      run: echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Create namespace if not exists
      run: |
        if ! kubectl get namespace diplom-nginx-namespace; then
          echo "Creating namespace diplom-nginx-namespace"
          kubectl create namespace diplom-nginx-namespace
        else
          echo "Namespace diplom-nginx-namespace already exists"
        fi

    - name: Create registry secret with IAM token
      run: |
        # Устанавливаем зависимости
        sudo apt-get update && sudo apt-get install -y jq
        
        # Создаем временный файл с JSON ключом
        echo '${{ secrets.YC_SA_JSON_KEY }}' > key.json
        
        # Получаем IAM токен через API
        IAM_TOKEN=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          -d @key.json \
          "https://iam.api.cloud.yandex.net/iam/v1/tokens" | \
          jq -r '.iamToken')
        
        if [ -z "$IAM_TOKEN" ] || [ "$IAM_TOKEN" = "null" ]; then
          echo "Error: Failed to get IAM token via simple API call"
          echo "Trying alternative approach with JWT..."
          
          # Альтернативный подход - создаем JWT вручную
          SERVICE_ACCOUNT_ID=$(jq -r '.service_account_id' key.json)
          PRIVATE_KEY=$(jq -r '.private_key' key.json | sed 's/\\n/\n/g')
          
          # Простой JWT создание (может потребовать доработки)
          HEADER='{"alg":"RS256","typ":"JWT"}'
          NOW=$(date +%s)
          EXPIRES=$(($NOW + 3600))
          PAYLOAD='{"aud":"https://iam.api.cloud.yandex.net/iam/v1/tokens","iss":"'$SERVICE_ACCOUNT_ID'","iat":'$NOW',"exp":'$EXPIRES'}'
          
          JWT_HEADER_B64=$(echo -n "$HEADER" | base64 -w0)
          JWT_PAYLOAD_B64=$(echo -n "$PAYLOAD" | base64 -w0)
          
          echo "$PRIVATE_KEY" > private_key.pem
          SIGNATURE=$(echo -n "${JWT_HEADER_B64}.${JWT_PAYLOAD_B64}" | openssl dgst -binary -sha256 -sign private_key.pem | base64 -w0)
          
          JWT_TOKEN="${JWT_HEADER_B64}.${JWT_PAYLOAD_B64}.${SIGNATURE}"
          
          IAM_TOKEN=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"jwt\": \"$JWT_TOKEN\"}" \
            "https://iam.api.cloud.yandex.net/iam/v1/tokens" | \
            jq -r '.iamToken')
        fi
        
        if [ -n "$IAM_TOKEN" ] && [ "$IAM_TOKEN" != "null" ]; then
          echo "IAM token received successfully"
          # Создаем secret с IAM токеном
          kubectl create secret docker-registry yc-registry-pull-secret \
            --docker-server=cr.yandex \
            --docker-username=iam \
            --docker-password="$IAM_TOKEN" \
            --namespace=diplom-nginx-namespace \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "Registry secret created with IAM token"
        else
          echo "Error: Could not get IAM token. Please check service account permissions."
          exit 1
        fi

    - name: Create nginx config for path routing
      run: |
        cat > nginx-config.yaml << 'EOF'
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: nginx-config
          namespace: diplom-nginx-namespace
        data:
          nginx.conf: |
            events {
                worker_connections 1024;
            }
            
            http {
                include /etc/nginx/mime.types;
                default_type application/octet-stream;
                
                server {
                    listen 80;
                    server_name _;
                    
                    location /nginx {
                        alias /usr/share/nginx/html;
                        index index.html;
                        try_files $uri $uri/ /nginx/index.html;
                    }
                    
                    location /nginx/ {
                        alias /usr/share/nginx/html/;
                        try_files $uri $uri/ =404;
                    }
                    
                    location = / {
                        return 302 /nginx;
                    }
                }
            }
        EOF
        kubectl apply -f nginx-config.yaml

    - name: Create or update deployment
      run: |
        cat > deployment.yaml << 'EOF'
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: diplom-nginx-app
          namespace: diplom-nginx-namespace
          labels:
            app: diplom-nginx-app
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: diplom-nginx-app
          template:
            metadata:
              labels:
                app: diplom-nginx-app
            spec:
              containers:
              - name: diplom-nginx-app
                image: ${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.TAG }}
                ports:
                - containerPort: 80
                resources:
                  requests:
                    memory: "64Mi"
                    cpu: "50m"
                  limits:
                    memory: "128Mi"
                    cpu: "100m"
                volumeMounts:
                - name: nginx-config
                  mountPath: /etc/nginx/nginx.conf
                  subPath: nginx.conf
                livenessProbe:
                  httpGet:
                    path: /nginx
                    port: 80
                  initialDelaySeconds: 10
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /nginx
                    port: 80
                  initialDelaySeconds: 5
                  periodSeconds: 5
              volumes:
              - name: nginx-config
                configMap:
                  name: nginx-config
                  #              imagePullSecrets:
                  #              - name: yc-registry-pull-secret
        EOF
        kubectl apply -f deployment.yaml

    - name: Create or update service
      run: |
        cat > service.yaml << 'EOF'
        apiVersion: v1
        kind: Service
        metadata:
          name: diplom-nginx-service
          namespace: diplom-nginx-namespace
        spec:
          selector:
            app: diplom-nginx-app
          ports:
          - port: 80
            targetPort: 80
          type: ClusterIP
        EOF
        kubectl apply -f service.yaml

    - name: Create ingress for nginx path
      run: |
        cat > ingress.yaml << 'EOF'
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: nginx-ingress
          namespace: diplom-nginx-namespace
          annotations:
            nginx.ingress.kubernetes.io/rewrite-target: /$2
            nginx.ingress.kubernetes.io/ssl-redirect: "false"
        spec:
          rules:
          - http:
              paths:
              - path: /nginx(/|$)(.*)
                pathType: Prefix
                backend:
                  service:
                    name: diplom-nginx-service
                    port:
                      number: 80
        EOF
        kubectl apply -f ingress.yaml

    - name: Wait for deployment rollout
      run: |
        kubectl rollout status deployment/diplom-nginx-app --namespace=diplom-nginx-namespace --timeout=300s

    - name: Verify deployment
      run: |
        echo "=== Deployment status ==="
        kubectl get deployments -n diplom-nginx-namespace
        echo "=== Pods status ==="
        kubectl get pods -n diplom-nginx-namespace
        echo "=== Service status ==="
        kubectl get services -n diplom-nginx-namespace
        echo "=== Ingress status ==="
        kubectl get ingress -n diplom-nginx-namespace
        echo "=== Registry secret ==="
        kubectl get secret yc-registry-pull-secret -n diplom-nginx-namespace
        echo "=== Current image version ==="
        kubectl describe deployment diplom-nginx-app -n diplom-nginx-namespace | grep Image:
